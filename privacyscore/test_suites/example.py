"""
This is an example test module. Its purpose is to document the interface
which is used for all tests.

Each test module has to define a test_site function and a process_test_data
function. The docstrings below explain their purpose.

The name of a test has to be supplied as test_name.
A test must declare a test_dependencies list containing the test_name of all
tests that need to be run before the test itself (and thus the results of that
tests are provided within the previous_results dictionary).
If a test does not have dependencies, an empty list should be supplied.
"""
# Copyright (C) 2017 PrivacyScore Contributors
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
import json
from typing import Dict, Union


test_name = 'example'
test_dependencies = ['another_example', 'foobar']


def test_site(url: str, previous_results: dict, **options) -> Dict[str, Dict[str, Union[str, bytes]]]:
    """
    The task of the test function is to scan the site and collect the raw
    data required in order produce a test result. It is **not** its task to
    process this data; it should just collect the data generated by the tools
    it uses, i.e. JSON results of subprocesses, the source code of the website
    or similar.

    It always gets the following positional arguments:
    * The url. This is the url of the site which should be tested.
    * A dictionary containing the *processed* results of all tests from
      previous test stages. If there have not been any tests yielding results
      in a previous stage, the dictionary is empty.

    In addition, a test function can get arbitrary parameters. The values
    for those parameters can then be specified in the settings where the test
    module is configured. Those parameters are static for all sites; they can
    be used to supply additional information like a path to an external script
    or a basedir for temporary data.

    The data collected by the test function should be returned as a dictionary
    where the keys are the identifiers of the raw data objects and the values
    are a dictionary containing the following information:
    * The mime_type specifying the mime type of the supplied raw data object.
    * The data object itself. It must be encoded as bytes.
    """

    # An example for a return value of the test function.
    return {
        'jsonresult': {
            'mime_type': 'application/json',
            'data': b'{"foo":42}',
        },
        'example': {
            'mime_type': 'text/plain',
            'data': b'an example raw data',
        },
    }


def process_test_data(raw_data: list, previous_results: dict, **options) -> Dict[str, Dict[str, object]]:
    """
    The task of the process function is to evaluate the raw data collected
    by the test function.

    It gets the raw data as first positional argument and the previous result
    dict, which is the same as supplied to the test function, as second argument.
    Additionally, all arbitrary parameters supplied to the test function are
    supplied to the process function as well.

    It should return a dictionary containing the relevant test results. The
    result dictionary contains result names as keys and their values as any
    json-serializable python object.
    The result dictionary is merged with the result dictionaries of all other
    tests. Therefore, keys should be globally unique; especially a
    test which runs in multiple modes should make sure to use different keys
    in different modes, for example a prefix based on the type (i.e. mx or a).
    """

    # Examples to retrieve raw data objects.
    json_data = json.loads(raw_data['jsonresult']['data'].decode())
    image = raw_data['screenshot']['data']
    database = raw_data['database']['data']

    # An example for a return value of the process function.
    return {
        'is_interesting': False,
        'respects_privacy': True,
        'pfs': False,
        'has_hsts_header': True,
        'has_hsts_preload_header': False,
        'has_hpkp_header': False,
    }
